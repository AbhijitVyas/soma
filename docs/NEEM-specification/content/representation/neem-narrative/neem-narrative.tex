
% % % % % % % % % % % % % % % % % % % % % % % %
% % % Prelude
% % % % % % % % % % % % % % % % % % % % % % % %
\newcommand{\givenODPNAME}{}
\newcommand{\givenODPINTENT}{}
\newcommand{\givenODPDEFINEDIN}{}
\newcommand{\givenODPGRAPHIC}{}
\newcommand{\givenODPEXAMPLES}{}
\newcommand{\givenODPQUESTION}{}
\newcommand{\ODPINTENT}[1]     {\renewcommand{\givenODPINTENT}{#1}}
\newcommand{\ODPDEFINEDIN}[1]  {\renewcommand{\givenODPDEFINEDIN}{#1}}
\newcommand{\ODPGRAPHIC}[1]    {\renewcommand{\givenODPGRAPHIC}{#1}}
\newcommand{\ODPEXAMPLES}[1]   {\renewcommand{\givenODPEXAMPLES}{#1}}
\newcommand{\ODPQUESTION}[1]   {\renewcommand{\givenODPQUESTION}{#1}}
\newcommand{\OPDinit}{
  \renewcommand{\givenODPINTENT}{REQUIRED!}
  \renewcommand{\givenODPDEFINEDIN}{REQUIRED!}
  \renewcommand{\givenODPGRAPHIC}{REQUIRED!}
  \renewcommand{\givenODPQUESTION}{}
  \renewcommand{\givenODPEXAMPLES}{}
  \renewcommand{\labelitemi}{$\mathbf{\sqsubseteq}$}
}

\newenvironment{ODP}[1]{
\OPDinit
\renewcommand{\givenODPNAME}{#1}
}{
%\givenODPDESCRIPTION
%\begin{figure}[htb!]
\vspace{0.2cm}
\begin{minipage}{0.55\textwidth}
\fcolorbox{easeblue!40}{easeblue!10}{\begin{tabular}{ p{1.8cm} p{4.2cm} }
%\toprule
% {\it\bf Name}                 & \emph{\givenODPNAME} \\
{\noindent\color{easeblue}\it\bf Intent}               & \givenODPINTENT \\
{\noindent\color{easeblue}\it\bf Competency Questions} & \emph{\givenODPQUESTION} \\
{\noindent\color{easeblue}\it\bf Defined in}           & \givenODPDEFINEDIN \\
%\bottomrule
\end{tabular}}
\end{minipage}
\begin{minipage}{0.45\textwidth}
\begin{center}
\givenODPGRAPHIC
\end{center}
\end{minipage}
\\[0.4cm]
\fcolorbox{easeblue!40}{easeblue!10}{
	\begin{minipage}{0.96\textwidth}
		\begin{tabular}{p{4.4cm}p{6.7cm}}
		{\noindent\color{easeblue}\it\bf Expression}  &
		{\noindent\color{easeblue}\it\bf Meaning} \\
		\givenODPEXAMPLES
		\end{tabular}
	\end{minipage}
}
%\caption{\emph{The Representation of \givenODPNAME}.}
%\end{figure}
\vspace{0.2cm}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NEEM-Narrative}
\label{ch:narrative}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Upper-Level Model}
\label{sec:narrative:commitments}

% NOTE: taken from SOMA paper
We decided to base our model on the DOLCE+DnS Ultralite (DUL) foundational framework~\cite{DOLCE2003}.
This decision is greatly motivated by their underlying ontological commitments.
%The decision to base our model on the DOLCE+DnS Ultralite foundational framework, is greatly motivated by their underlying ontological commitments.
Firstly, DUL is not a revisionary model, but seeks to express stands that shape human cognition. Furthermore it assumes a reductionist approach -- rather than capturing, for example, the flexibility of our usage of objects via multiple inheritance in a multiplicative manner, we commit to a reduced {\it ground} classification and use a {\it descriptive} approach for handling this flexibility. For this a primary branch of the ontology represents the ground {\bf physical model}, e.g. objects and actions, while a secondary branch represents the {\bf social model}, e.g. roles and tasks. All entities in the social branch would not exist without humans, i.e. they constitute social objects that represent concepts about or descriptions of ground elements. 

% NOTE: taken from SOMA paper
Every axiomatization in the physical branch can, therefore, be regarded as expressing some physical context whereas axiomatizations in the descriptive social branch are used to express social contexts. A set of dedicated relations is provided that connect both branches. For example, as detailed in Section~\ref{subsec:roles}, the relation \emph{classifies} connects ground objects, e.g. a hammer, with the roles they can play, i.e. potential classifications. Thus, we can state that a hammer can in some context be conceptualized as a murder weapon, a paper weight or a door stopper. Nevertheless, neither its ground ontological classification as a tool will change nor will hammers be subsumed as kinds of door stoppers, paper weights or weapons via multiple inheritance. Following a quick overview of the central modules of SOMA where these commitments apply, we will provide detailed examples of where and how our commitments apply in Sections~\ref{sec:perdurants} and~\ref{sec:endurants}.

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Taxonomy}
\label{sec:taxonomy}
\textbf{todo: Abhijit write me}

\paragraph{Actions} \dots \textbf{(todo: write about task taxonomy)}
\paragraph{Motions} \dots \textbf{(todo: write about motion taxonomy)}
\paragraph{Objects} \dots \textbf{(todo: write about object taxonomy)}
\paragraph{Roles} \dots \textbf{(todo: write about role taxonomy)}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Occurrences}
\label{sec:occurrences}
%% Summary of Figure below
The basic building blocks of NEEMs are the events that occur during the course of an activity. An event is defined as \emph{any physical, social, or mental process, event, or state}. Events have an associated time interval that determines the time at which the event occurs. Time data is represented as unix timestamps using XSD types.
%As discussed in porevious section, we distinguish between three different event classes: \owlClass{Action}, \owlClass{State}, and \owlClass{Process}.

\begin{ODP}{Occurences}
	\ODPINTENT{To quantify when something has happened.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{Did it happen? When did it happen?}
	\ODPGRAPHIC{\begin{tikzpicture}
	    \node[owlclass] (EVT) {Event};
	    \node[owlclass,below=0.6cm of EVT] (TI) {Time Interval};
	    \node[data,below=0.6cm of TI,xshift=-1.2cm] (BEGIN) {xsd:double};
	    \node[data,below=0.6cm of TI,xshift=1.2cm] (END) {xsd:double};
	    \draw (EVT) edge[relation] node[midway,label=right:hasTimeInterval] {} (TI);
	    \draw (TI)  edge[relation] node[midway,label=left:hasIntervalBegin] {} (BEGIN);
	    \draw (TI)  edge[relation] node[midway,label=right:hasIntervalEnd] {} (END);
	\end{tikzpicture}}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{occurs('EV')} &
		\emph{EV} is an occurence \\
		% % % % %
		\emph{occurs('EV') during [10,14]} &
		\emph{EV} occurs between the times $10$ and $14$ \\
		% % % % %
		\emph{occurs('EV') since 10} &
		\emph{EV} occurs since the time $10$ \\
		% % % % %
		\emph{occurs('EV0') since 'EV1'} &
		\emph{EV0} and \emph{EV1} begin at the same time
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Participation}
\label{sec:participation}
%% Summary of Figure below
Events always involve some objects that play a certain role during the event. The role of being the \emph{patient} of some event being an example. This is that the event is directed towards the object. It is not always directly observable what the role of an object might be, however, it is less problematic to just state that the object \emph{has participated} in some event without naming a role.

\begin{ODP}{Participation}
	\ODPINTENT{To represent participation of an object in an event.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{Which objects do participate in this event? In which events does this object participate in?}
	\ODPGRAPHIC{\begin{tikzpicture}
	    \node[owlclass] (EVT) {Event};
	    \node[owlclass,below=0.6cm of EVT] (OBJ) {Object};
	    \draw (EVT) edge[relation] node[midway,label=left:hasParticipant] {} (OBJ);
	\end{tikzpicture}}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{has\_participant('EV','O')} &
		\emph{O} is involved in event \emph{EV} \\
		% % % % %
		\emph{has\_participant('EV',X)} &
		what are the entities involved in \emph{EV}? \\
		% % % % %
		\emph{has\_participant(X,'O')} &
		what are the events involving \emph{O}?
	}
\end{ODP}

\textbf{todo: Sascha write this}
\lipsum[2]

\begin{ODP}{Action Execution}
	\ODPINTENT{To represent that an agent has executed an action.}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (EVT) {Action};
	    \node[owlclass,below=0.6cm of EVT] (A) {Agent};
	    \draw (EVT) edge[relation] node[midway,label=right:isPerformedBy] {} (A);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} & ??
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Force Interaction}

\textbf{todo: Daniel write this}
\textbf{todo: preservative vs. alterative interaction}
\textbf{todo: how to represent who is stronger? can measured forces be included in the NEEM?}
\textbf{todo: isProcessTypeOf relation is not nice}
\lipsum[2]

\begin{ODP}{?}
	\ODPINTENT{To qualify force dynamical event characteristics.}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{What entity is the agonist in this event? What are the events where this entity is an antagonist? Which entity is stronger in this event?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (B) {Force Interaction};
	    \node[owlclass,below=0.6cm of B,xshift=-1.3cm] (C) {Agonist};
	    \node[owlclass,below=0.6cm of B,xshift=1.3cm]  (D) {Antagonist};
	    \node[owlclass,above=0.6cm of B] (E) {Stronger Entity};
	    \draw (B) edge[relation] node[midway,label=left:xx] {} (C);
	    \draw (B) edge[relation] node[midway,label=right:xx] {} (D);
	    \draw (B) edge[relation] node[midway,label=left:xx] {} (E);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} & ??
	}
\end{ODP}

\lipsum[2]

\begin{ODP}{?}
	\ODPINTENT{To quantify force dynamical event characteristics.}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{What is the effort of the agonist in this event?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (B) {Force Interaction};
	    \node[owlclass,below=0.6cm of B,xshift=-1.3cm] (C) {Resultant};
	    \node[owlclass,below=0.6cm of C] (D) {Effort};
	    \node[data,right=0.6cm of D] (E) {$Nm$};
	    \draw (B) edge[relation] node[midway,label=right:xx] {} (C);
	    \draw (C) edge[relation] node[midway,label=right:xx] {} (D);
	    \draw (D) edge[relation] node[midway,label=above:xx] {} (E);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} & ??
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Composition}
\label{sec:composition}

\textbf{todo: Mihai write this.}
\textbf{todo: why isn't hasPhase Event-to-Event?}
\lipsum[2]

\begin{ODP}{Event Phases}
	\ODPINTENT{To represent how an event is composed of phases.}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{What are the phases of this action? Is this a phase of some action?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (E) {Event};
	    \path (E) edge[relation,loop above] node {hasPhase} (E);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{has\_phase('A','B')} &
		\emph{B} is a phase of \emph{A}
	}
\end{ODP}

\lipsum[2]

\begin{ODP}{Composition}
	\ODPINTENT{To represent proper parthood.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{What is this object component of? What are the components of this object?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (E) {Object};
	    \path (E) edge[relation,loop above] node {hasComponent} (E);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{has\_component('A','B')} &
		\emph{B} is a proper part of \emph{A} \\
		% % % % %
		\emph{has\_component('A',X)} &
		What are the components of \emph{A}? \\
		% % % % %
		\emph{has\_component(X,'A')} &
		What are the entities \emph{A} is component of? \\
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Conceptual Classification}
\label{sec:classification}

The classification of entities in SOMA is done from multiple viewpoints.
The most essential one is \emph{what the entitiy really is}.
This is reflected in the taxonomy of SOMA.
However, entities may further be classified according to social aspects such as intention, purpose, etc.
This type of classification is based on the \emph{conceptualization} of entities.
In particular, conceptualizations of objects and events are used to classify them in the scope of some activity.
For this purpose,
SOMA includes a comprehensive collection of concepts that are used to classify objects and events from a conceptual viewpoint (\textbf{todo: insert link to list of all concepts}).

\lipsum[2]

\begin{ODP}{Object Role}
	\ODPINTENT{To represents objects and the roles they play.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{What role does this object play? Which objects do play that role?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Object};
	    \node[owlclass,below=0.6cm of EVT] (B) {Role};
	    \draw (A) edge[relationxl] node[midway,label=left:$\text{hasRole}_t$] {} (B);
	    \draw (B) edge[relationxr] node[midway,label=right:$\text{isRoleOf}_t$] {} (A);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} &
		??
	}
\end{ODP}

% A Concept that classifies an Event . An event type describes how an Event should be interpreted, executed, expected, seen, etc., according to the Description that the EventType isDefinedIn (or used in)
\lipsum[2]

\begin{ODP}{??}
	\ODPINTENT{??}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{??}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Event};
	    \node[owlclass,below=0.6cm of EVT] (B) {Event Type};
	    \draw (A) edge[relationxl] node[midway,label=left:isOccurrenceOf] {} (B);
	    \draw (B) edge[relationxr] node[midway,label=right:isOccurringIn] {} (A);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} &
		??
	}
\end{ODP}

%This ODP allows to make assertions on roles played by agents without involving the agents that play that roles, and vice versa. It allows to express neither the context type in which tasks are defined, not the particular context in which the action is carried out. Moreover, it does not allow to express the time at which the task is executed through the action (for actions that do not solely execute that certain task).
\lipsum[2]

\begin{ODP}{Task Execution}
	\ODPINTENT{To represent actions through which tasks are executed.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{Which task is executed through this action? What actions could execute that task?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Action};
	    \node[owlclass,below=0.6cm of EVT] (B) {Task};
	    \draw (A) edge[relationxl] node[midway,label=left:executesTask] {} (B);
	    \draw (B) edge[relationxr] node[midway,label=right:isExecutedIn] {} (A);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{??} &
		??
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Object Properties}
\label{sec:qualification}

Qualities are the properties of an object that are not part of it, but cannot exist without it.
This is, for example, the quality of having a shape -- a quality inherited by all physical objects.
Another example is the quality of a floor being slippery.
A robot navigating on such a floor could use this knowledge to avoid, for example,
spillage when moving on the floor with a coffee-filled cup.
The quality concept does not directly encode the value of the object property, but only focusses on characteristics of the property itself.
This is mainly useful in cases where individual aspects of an entity are considered in the domain of discourse.

\begin{ODP}{Object Qualities}
	\ODPINTENT{To represent the qualities of an object.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{What qualities does this object have? That are the objects with this quality?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Object};
	    \node[owlclass,below=0.6cm of EVT] (B) {Quality};
	    \draw (A) edge[relation] node[midway,label=right:hasQuality] {} (B);
 %\node[owlclass] (QUALITY) {
 %\begin{owlclass}{Quality}
 % \item $(\exists \emph{isQualityOf}.\texttt{Entity})$
 % \item $(\exists \emph{hasRegion}.\texttt{Region})$
 %\end{owlclass}
 %};
 %\node[owlclass,below=0.6cm of QUALITY] (REGION) {
 %\begin{owlclass}{Region}
 % \item $(\exists \emph{isRegionFor}.\texttt{Quality})$
 %\end{owlclass}
 %};
 %\draw (QUALITY) edge[thick,-,dashed,blue!60] (REGION);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{has\_quality('A','B')} &
		\emph{B} is a quality of \emph{A} \\
		% % % % %
		\emph{has\_quality('A',X)} &
		What are the qualities of \emph{A}? \\
		% % % % %
		\emph{has\_quality(X,'A')} &
		What entity is the host of \emph{A}? \\
	}
\end{ODP}

Each object property has one value at a time. The value of an object property is called \emph{region}.
The value itself is an element, or a sub-region in some dimensional
space such as \emph{time interval} or \emph{space region}.
A region may be a finite set of discrete labels, allowing for ``qualitative'' descriptions,
but more often a region is some dimensional space allowing ``quantitative'' descriptions.
A Region may contain a single point, in cases where the value of a property is known precisely.
Note that the domain of the relation \emph{hasRegion} is not \emph{Quality} but \emph{Entity}.
This is to allow assigning regions to entities without explicating the quality as a concept (quality-as-relation).

\begin{ODP}{Regions}
	\ODPINTENT{To represent values of attributes of things.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{What is the value for the attribute of that entity? Which entities have a certain value on that parameter/attribute/feature?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Entity};
	    \node[owlclass,below=0.6cm of EVT] (B) {Region};
	    \node[data,below=0.6cm of B] (C) {XSD Type};
	    \draw (A) edge[relation] node[midway,label=right:hasRegion] {} (B);
	    \draw (B) edge[relation] node[midway,label=right:hasRegionDataValue] {} (C);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{has\_region('A','B')} &
		\emph{B} is a region of \emph{A} \\
		% % % % %
		\emph{has\_region('A',X)} &
		What is the region of \emph{A}? \\
		% % % % %
		\emph{has\_data\_value('A','B')} &
		\emph{B} is a data value of \emph{A} 
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Object Transformation}
\label{sec:transformation}

Objects typically undergo changes by taking part in actions or processes. Such changes typically take one of two forms: either some property of an object changes value, or the object itself modifies its ontological characterization. As an example, a wad of dough being transported from the table to the inside of an oven has changed its position, but is still, at this point, a wad of dough. Left in a hot oven for enough time however, the wad of dough becomes bread.

The variation with time of object qualities has been described in section~\ref{sec:qualification}. The object transformation pattern, described here, handles the changes of an object's ontological classification through time. An immediate problem is that ontological characterizations are necessarily discrete -- there is a finite number of classes an object can belong to -- while change in the physical world is continuous. In the example above, the wad of dough ceases to be dough after a few moments in the oven, because its chemical composition is changing away from the composition of dough. Nonetheless, it is not bread yet.

For practical purposes however, human beings often do not care about the exact classification of an object undergoing ontological change; only the endpoints are important. Also, there is a tendency to loosely apply ontological classification to the changing object, as if it were on either side of the transformation. The cooking wad of dough could be referred to as dough, or it could be referred to as bread. It is both, and neither. While sufficient for causal discourse, such carelessness would not work in a formal system. Hence, the approach in SOMA is to define a class of objects called \emph{Transient}, and it is to this class that objects undergoing ontological classification change belong to. A Transient \emph{transitionsFrom} some object with a specific classification (e.g. \emph{Dough}) and \emph{transitionsTo} another object with a specific classification (e.g. \emph{Bread}). These two relations can be combined into the \emph{transitionsBack} relation, to cover situations where an object changes in essential ways during an event, but returns to being itself after the event completes, such as a catalyst in a chemical reaction.
 
% This pattern addresses the fact that objects change by undergoing/taking part in Processes. For example, the PancakeMix becomes, through Baking, a Pancake. However, the ontological status of the object while the process takes place is unclear: the object placed on the frying pan is not a Pancake until Baking finishes, but it's not PancakeMix either once it begins to coagulate. In the EASE approach, the object in-between such characterizations is a Transient. A Transient transitionsFrom an Object, and possibly transitionsTo an Object. It may also be the case that a Transient transitionsBack to an Object, to indicate that once the process completes, the same Object is restored; this would be the case for example for catalysts in chemistry, or a loaf of bread after slicing, if there is enough bread left.
%\lipsum[2]

\begin{ODP}{Transient}
	\ODPINTENT{Ontological classification for objects undergoing type changes.}
	\ODPDEFINEDIN{SOMA.owl}
	\ODPQUESTION{What sort of object is this? What objects ``went'' into the making of another? What is the outcome of some process of change acting on an object? Does an object preserve or restore its identity after change?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
 %\node[owlclass] (TRANSIENT) {
 %\begin{owlclass}{Transient}
 % \item \texttt{Object}
 % \item $(\exists\emph{transitionsFrom}.\texttt{Object})$
 % \item $(\forall\emph{transitionsTo}.\texttt{Object})$
 %\end{owlclass}
 %};
 %\node[owlclass,below=0.6cm of TRANSIENT] (TRANSITIONSBACK) {
 %\begin{owlclass}{transitionsBack}
 % \item \texttt{transitionsFrom}
 % \item \texttt{transitionsTo}
 %\end{owlclass}
 %};
	    \node[owlclass] (A) {Transient};
	    \node[owlclass,below=0.6cm of EVT] (B) {Object};
	    \node[owlclass,above=0.6cm of EVT] (C) {Object};
	    \draw (A) edge[relation] node[midway,label=right:transitionsFrom] {} (B);
	    \draw (A) edge[relation] node[midway,label=right:transitionsTo] {} (C);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{transitionsFrom('A','B')} & By entering some process of change, object 'B' becomes Transient object 'A'.\\
		\emph{transitionsTo('A','B')} & By completing some process of change, transient 'A' becomes object 'B'.\\
		\emph{transitionsBack('A','B')} & Object 'B' entered some process of change during which its ontological classification is unclear and it is replaced by Transient 'A', but after the process completes object 'B' is restored.\\
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Episodes}
\label{sec:episodes}

An episode is seen as a \emph{relational context} created by an observer that creates a view on a set of entities such as actions that were perfomed, and objects that played a role. We say that an episode is a \emph{setting for} each entity that is relevant for the scope of the episode. As an example, consider the statement \emph{"this morning the robot made a mess on the floor while preparing coffee"}, where the preparation of coffee in the morning is the setting for the robot, the floor, and the actions that were perfomed.
Several specializations of the general \emph{is setting for} relation exist that can be used to distinguish between entities based on their type -- these are, among others, \emph{includesObject} and \emph{includesAgent}.

\begin{ODP}{isSettingFor}
	\ODPINTENT{To represent that entites are included in a situation.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{What are the entities that are relevant for this situation? What are the situations where this entity is relevant?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Situation};
	    \node[owlclass,below=0.6cm of EVT] (B) {Entity};
	    \draw (A) edge[relation] node[midway,label=right:isSettingFor] {} (B);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{is\_setting\_for('Episode1', 'Obj1')} &
		\emph{Episode1} is a setting for \emph{Obj1} \\
		% % % % %
		\emph{is\_setting\_for('Episode1', X)} &
		What is \emph{Episode1} setting of? \\
		% % % % %
		\emph{is\_setting\_for(X, 'Evt1')} &
		What are the episodes that include \emph{Evt1}? \\
	}
\end{ODP}

Episodes refer to concrete occurences with actual objects that are involved, and actual events that occur.
The conceptualization of an episode is an abstraction that refers to concepts instead.
Such conceptualizations are called \emph{descriptions}.
We say that an episode \emph{satisfies} a description in case the view represented
by the episode is consistent with the conceptualization given by the desciption.
Diagnosis being one example of a description of an episode.
Stating that the performance of the robot was \emph{amateurish} when it made a mess on the floor while
preparing coffee is one example for describing an epsiode.
Another type of descriptions are plans that are used to conceptualize the structure of an activity.

\begin{ODP}{satisfies}
	\ODPINTENT{To represent a conceptualization of a situation.}
	\ODPDEFINEDIN{DUL.owl}
	\ODPQUESTION{How can this situation be conceptualized? What are the situations that are consitent with this conceptualization?}
	\ODPGRAPHIC{
	\begin{tikzpicture}
	    \node[owlclass] (A) {Situation};
	    \node[owlclass,below=0.6cm of EVT] (B) {Description};
	    \draw (A) edge[relation] node[midway,label=right:satisfies] {} (B);
	\end{tikzpicture}
	}
	%% Example KnowRob language expressions
	\ODPEXAMPLES{
		\emph{satisfies('Episode1', 'Descr1')} &
		\emph{Episode1} is consistent with \emph{Descr1} \\
		% % % % %
		\emph{satisfies('Episode1', X)} &
		What are conceptualization of \emph{Episode1}? \\
		% % % % %
		\emph{satisfies(X, 'Descr1')} &
		What are the episodes that are conceptualized by \emph{Descr1}? \\
	}
\end{ODP}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %

\iffalse
\begin{ODP}{Process vs. Action}
%\ODPDESCRIPTION{An Action is an Event with at least one Agent participant, such that this Agent has a Task, often defined by a Plan or Workflow, which it executes through the Action. A Process is an Event for which no such commitments have been made. In DUL, these classes are not disjoint, allowing a particular event individual to be classified as either, depending on whether we care to record an agent and its goals or not. In EASE, we use Process as a top-level class for events with no agentive participant.}
\ODPINTENT{To represent the intentional and agentive structure-- or lack thereof-- behind Events.}
\ODPDEFINEDIN{DUL.owl}
\ODPQUESTION{
  \emph{Is there anyone responsible for the event?}
  \emph{What are they trying to do?}
  \emph{How did an event unfold?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (ACTION) {
 \begin{owlclass}{Action}
  \item \texttt{Event}
  \item $(\exists \emph{hasParticipant}.\texttt{Agent})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of ACTION] (PROCESS) {
 \begin{owlclass}{Process}
  \item \texttt{Event}
 \end{owlclass}
 };
\end{tikzpicture}
}
\end{ODP}

\begin{ODP}{State, Configuration, Gestallt}
%\ODPDESCRIPTION{A state is a configuration of the world that is construed to be stable on its own. Outside disturbances may cause state transitions, and the settling into some other, self-stable configuration. A State is also characterized by a Description, that indicates things such as what kind of entities participate in the state, what relations might exist between them, what regions may be used by particular qualities of the participants. This Description is, in general, referred to as a Configuration, however some common examples are Goals-- describe desired states of the world--, Norms-- describe states that should be kept--, and Diagnoses-- describe a state that causes certain observable symptoms. States are classified by Gestallts. \textbf{TODO}: Generalize this and/or split it: classification by an event type and structuring by a description are different ODPs in the current list. All three event subclasses (Actions, Processes, States) now are each part of their own Event-Concept-Description triad, where the Concept classifies the Event, and the Description, by describing the classifying Concept, structures the Event.
}
\ODPINTENT{Ontological representation for situations in the world that are cognitively construed as stable arrangements of entities.}
\ODPDEFINEDIN{EASE-STATE.owl}
\ODPQUESTION{
  \emph{What are stable arrangements?}
  \emph{What is meant by ``state'' of the world?}
  \emph{What characterizes a state?}}
\emph{Examples}
%\begin{itemize}
%  \item AssemblyConnection: two objects are in a rigid connection, such that the movement of one determines the movement of the other. In this case the characterizing Configuration for this State uses several Roles-- one for each part/geometric feature belonging to the connected objects-- and puts constraints on the relative positioning of these geometric features such that they interlock to produce the rigid connection.
%  \item Contact: two objects are in mechanical contact. The characterizing Configuration uses two Roles, one for each participating object, and puts constraints on the Pose qualities of the participants: the poses should be such that the participants touch.
%  \item FunctionalControl: an object restricts the movement of another, at least partially. The Configuration uses the Roles Item and Restrictor. More concrete examples are Containment: the Restrictor is a Container, and the Pose quality of the Item should use the region inside the Container; and Support: both Restrictor and Item are objects, placed in such a way that the Item does not move because of gravity.
%  \item PhysicallyAccessible: the Configuration for this state uses the roles Item, a Container or Protector, and optionally an Accessor and a Task, and states that an Item is either placed in a Container or protected by a Protector, but the placement of the Item and Container is such that an Accessor may nevertheless reach the Item in order to perform a Task. For a more concrete example, a DoorOpen is a kind of PhysicallyAccessible where the Protector is a door, the Item is the inside of the room behind the door, the Accessor is some person and the Task is to walk into the inside of the room.
%\end{itemize}
\end{ODP}

\begin{ODP}{Designed Artifact}
%\ODPDESCRIPTION{A DesignedArtifact is a physical object described by a Design. In EASE, Designs refer to the form, but also the function of an object. This allows us to say that an object is ``for'' a particular purpose, even though it might be used for something else instead. For example, a cup is a BeverageContainer but can be used as a Flowerpot. Designs form a hierarchy of specificity, for example $DesignMilkContainer \sqsubseteq DesignBeverageContainer \sqsubseteq DesginContainer \sqsubseteq Design$. The justification for this pattern is that the type of an object is rigid, but the roles it plays in events change. A naive taxonomy, without a notion similar to Design, cannot tackle the fact that objects are usable in several ways beyond the obvious; a hammer isn't always a hammer, sometimes it's a paperweight. On the other hand, a usable ontology of objects must take into account how human users refer to objects by their default use.}
\ODPINTENT{To explicate the intuitive classification human users would have of objects, based on their default uses.}
\ODPDEFINEDIN{DUL.owl, EASE.owl, EASE-middle.owl}
\ODPQUESTION{
  \emph{What sort of object is this?}
  \emph{What is the intended use of the object?}
  \emph{How did an event unfold?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (DESIGNEDARTIFACT) {
 \begin{owlclass}{DesignedArtifact}
  \item \texttt{PhysicalArtifact}
  \item $(\exists\emph{isDescribedBy}.\texttt{Design})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of DESIGNEDARTIFACT] (DESIGN) {
 \begin{owlclass}{Design}
  \item \texttt{Description}
 \end{owlclass}
 };
 \draw (DESIGNEDARTIFACT) edge[thick,-,dashed,blue!60] (DESIGN);
\end{tikzpicture}
}
\end{ODP}
\fi

% In version \neemversion the \neemnar consists the belief state and action task hierarchy. 
% In the following sections we will describe how the belief state and action task hierarchy are represented.
% An concrete example for a logged \neemnar will be given in Chapter \ref{ch:example}.

% \subsection{Belief State}
% \input{content/representation/neem-narrative/beliefstate}

% \subsection{Action Hierarchy}
% \label{ch:narrative,sec:actionHierarchy}
% In this section, we will describe how an action task hierarchy is represented in the \neemnar. 
% Since we are using \cram on our robots our plans do not necessary generate a sequence of actions, instead they will generate rather an hierarchy of actions.
% During the plan execution we are logging all executed actions with its parameters and represent the hierarchy in \owl.
% The general idea of the model is that an action will be represented as an individual of the class \owlClass{knowrob:'Action'}.
% This individual can be a direct instance of the class \owlClass{knowrob:'Action'} or its subclass.
% \todo{Add all supported action sub classes}
% With the predicates \owlPredicate{subAction}, \owlPredicate{previousAction} and \owlPredicate{nextAction}, which all have as subject and object the type \owlClass{knowrob:'Action'}, we are able to represent the action hierarchy.
% In our understanding an logged action hierarchy in an \owl represents all actions which were executed during an experiment.
% Meaning, if we would extracted all actions from the \owl file and recreated the action tree, we would be able to analyze and reasoning about all executed actions during one specific experiment.

% In the next subsections we will describe the predicates and classes which we currently defined in the version \neemversion to log the actions which were executed by the robot during an experiment. 

% \subsection{Action Predicates}
% Every individual of the class \owlClass{knowrob:'Action'} class or its subclass which will be logged in the \owl file can be asserted with the following predicates (see Table \ref{table:action_task_predicates}).
% Some predicates in the table are marked as required.
% This means that if you are intending to upload your \owl file to \openease, every \owlClass{knowrob:'Action'} individual has to have the required properties asserted.
% %Otherwise the \owl file will be revoked from the server.\todo{We have to implement such checking in \openease.}
% The \openease server checks also if the objects of the predicates are associated with the correct class.

% \begin{table}[H]
% 	\begin{tabular}{| c | c | c | c |}
% 		\hline			
% 		\textbf{Subject} & \textbf{Predicate} & \textbf{Object}  & \textbf{Required} \\
% 		\hline
% 		Action & taskSuccess & xsd:boolean & Yes \\
% 		\hline
% 		Action & startTime & Timepoint & Yes \\
% 		\hline
% 		Action & endTime & Timepoint  & Yes \\
% 		\hline
% 		Action & subAction & Action & No \\
% 		\hline
% 		Action & nextAction & Action & No \\
% 		\hline
% 		Action & previousAction & Action & No \\
% 		\hline
% 	\end{tabular}
% 	\caption{Action Predicates}
% 	\label{table:action_task_predicates}
% \end{table}

% \begin{description}
% 	\item[\textbf{taskSuccess}] 
% 		This predicates points to data type \owlClass{xsd:boolean}.
% 		The value \textbf{true} represents that the action was executed successfully.
% 		If any errors occurred during the action execution, the data type will be set to \textbf{false}.
% 		\footnote{In the NEEM version \neemversion we do not log the exact error which happened during action.}
% 	\item[\textbf{startTime}]
% 		The \owlPredicate{startTime} represents when the action started.
% 		Instead of representing the startTime as a data point, we are creating an instance of the class \owlClass{Timepoint}.
% 		The implemenation is done in that way because it made writing prolog queries much more convenient. 
% 		The name of the individual is representing the exact time when the action started e.g.\ \textit{timepoint\_1523878415038090} which can be understood that the action started 1523878415038090 microseconds after 00:00:00 UTC, Thursday, 1 January 1970.
% 		We are using the Unix time to represent a time point \cite{matthew2011beginning}.
% 		However, we are considering to measure the time in microseconds.
% 		The reason for this decision is that we also want to create NEEMs in simulation.
% 		However, tasks in simulation can be executed so fast that logging in microseconds allowed to measure the performance of the task executions.
% 		Also the measurement in microseconds allowed to differentiate the running time between tasks.
% 	\item[\textbf{endTime}] 
% 		This predicate represents when the action ended.
% 		More information about how we log time points is described in the predicate description \owlPredicate{startTime}.
% 	\item[\textbf{subAction}]
% 		The predicate \owlPredicate{subAction} allows to create parent-child relation between two tasks. In the context of this predicate, the subject is the parent action and the object is the child action.
% 		It is possible that an \owlClass{Action} instance can have multiple \owlPredicate{subAction} predicates which point each to a single child action.
% 	\item[\textbf{nextAction}]
% 		To be able to create an sequential order of actions which where executed on the same hierarchy level, we defined the \owlPredicate{nextAction} predicate.
% 		The subject represents the action which was started first and points to the next sibling actions.
% 		\footnote{In the NEEM version \neemversion we are not differentiate if actions were executed in sequence or in parallel.}
% 	\item[\textbf{previousAction}]
% 		Like in \owlPredicate{previousAction} this predicate is created to create an sequential order between siblings tasks.
% 		However in this case, \owlPredicate{previousAction} connects an \owlClass{Action} instance with the sibling action which was performed previously.
% \end{description}


% \subsection{Action Parameter Predicates}
% 	\label{sec:actionParameterPredicactes}
% 	In general, actions have to have parameters which have to be asserted.
% 	Based on those assertions \cram is able to infer how to perform the task.
% 	For instance, a grasping task will be executed differently when the target object is a spoon compared to when the target object is a bottle.
% 	To understand the logged behavior of the robot better, we are logging to each action the corresponding parameters.
% 	For \cram we are using for our actions a set of predefined parameters.
% 	For example, when an action requires an object every \cram action has parameter name \textit{object} asserted.
% 	During the logging process, we are creating based on the parameter's value an instance of the class \owlClass{Object} and connect this instance with the \owlPredicate{objectActedOn}.
% 	\todo{Ref to belief state when object description is done}
% 	This implementation allows us to use the logger for new actions without the need to extend the logger.
% 	As long the \cram actions will use the predefined parameter names all parameters will be logged without the need to extend the logger.
% 	All predefined parameters are represented by a separated predicates which point to the parameter value which is an individual of the corresponding \owl class.
% 	Table \ref{table:action_parameter_predicates} shows the current parameter predicates which are supported by our NEEM representation.
% 	The design of the action parameter predicates is based on the work with our \pr.
% 	Therefore in the NEEM \neemversion it might be possible that the action parameters cannot be used by everyone in this state.
	 
% \begin{table}[H]
% \begin{tabular}{| c | c | c |}
% 	\hline			
% 	\textbf{Subject} & \textbf{Predicate} & \textbf{Object} \\
% 	\hline			
% 	Action & effort & qudt\#NewtonMeter \\
% 	\hline
%     Action & position & Float \\
%     \hline
% 	Action & arm & Pr2\#Pr2RightArm \\
% 	\hline
% 	Action & bodyPartsUsed & Pr2\#Pr2RightGripper \\
% 	\hline
% 	Action & goalLocation & Pose or Connected Space Region \\
% 	\hline
%     Action & objectActedOn & Object \\
% 	\hline
% 	Action & objectType & Object \\
% 	\hline
% \end{tabular}
% 	\caption{Action Parameter Predicates}
% 	\label{table:action_parameter_predicates}
% \end{table}

% \begin{description}
% 	\item[\textbf{effort}] 
% 		Effort is the grasping force in newton-meters.
% 		To model this we are using the \qudt ontology \footnote{http://qudt.org/}.
% 	\item[\textbf{position}]
% 		We are using this predicate to log the the goal position for the gripper of the \pr.
% 		The \pr accepts a joint angle in RAD to position its gripper.
% 		We decided to use a float data type to model the position to be able to represent more different types of position.
% 		For instance, our \boxy robot uses centimeters to position the gripper.
% 		Therefore with a float representation we are able to log from both robots the position parameter.
% 	\item[\textbf{arm}]
% 		With this predicate we want to log which arm was used to by the robot.
% 		The predicate points to an instance of the specific robot arm class.
% 		For instance, to model that the \pr used a right arm to grasp a bottle we are asserting the \owlPredicate{arm} predicate to an individual of the class \owlClass{Pr2RightArm}\footnote{http://knowrob.org/kb/PR2.owl}.
% 	\item[\textbf{bodyPartsUsed}]
% 		The \owlPredicate{bodyPartsUsed} predicate should represent which body part from the robot was used to perform the task.
% 		This predicate can be used \eg to represent that a gripper was used to perform the task.
% 		Like in \dots we also want to represent the body part as instance of the class which represents the body part.
% 	\item[\textbf{goalLocation}]
% 		This predicate can be used to represent the target or location parameter of an action.
% 		This predicate is suitable to represent \eg the target location of an \textit{Going} action.
% 		We are considering to different object types to log the goal location.
% 		Since our robots are build on \ros our robots can work with \textit{Poses} \footnote{http://docs.ros.org/api/geometry\_msgs/html/msg/Pose.html}.
% 		How we represent this \owl class is stated out in section \ref{sec:pose}.
		
% 		Since we are also using \cram, our robots can also encounter \textit{location designator} as goal locations\cite{beetz2010cram}.
% 		That means \cram can handle tasks like "Go to the kitchen counter".
% 		Since locations designators are more abstract we use the \owl class \owlClass{Connected Space Region} to log them.
% 		A more detailed description is given in section \ref{sec:connectedSpaceRegion}.
		
% 	\item[\textbf{objectActedOn}]
% 		With the predicate \owlClass{objectActedOn} we want to log which objects are given as parameter to the action.
% 		For instance, we can log which objects the robots looked for during a perception task and what objects he tried to grab.
% 	\item[\textbf{objectType}]
% 		The difference of \owlPredicate{objectType} compared to \owlPredicate{objectActedOn} is that \owlPredicate{objectType} define not a specific object but rather an object in general.
% 		For instance, if the robotic agent will get a task such as "grab the milk from the fridge".
% 		Given the task, the agent knows only that it has to grab a object of the type of milk from the fridge.
% 		So at this moment the robot does not know if the a milk box is actually in the fridge.
% 		Thereofre it has to recognize the milk first.
% 		If this was sucessfull then the robot will assoicated the following task the milk ID with the predicate \owlPredicate{objectActedOn} which the object will be the link to the speicifc object in the belieft state.
% \end{description}

% \subsection{Action Parameter Classes}
% As shown in section \ref{sec:actionParameterPredicactes} we are not only using data types to log the action parameter.
% In this section we are describing the \owl classes which we introduced to be able to log all parameters which we required to log during our experiments.

% \subsubsection{Pose}
% 	\label{sec:pose}
% 	This class is used to log coordinates given as parameter.
% 	Since our robots are using \ros we are logging poses.
% 	A pose consists from a Quaternion and a 3D vector.
% 	Since both together can only describe a Pose, both entities are required to be logged.
% 	\begin{table}[H]
% 		\begin{tabular}{| c | c | c | c |}
% 			\hline			
% 			\textbf{Subject} & \textbf{Predicate} & \textbf{Object} & \textbf{Required}\\
% 			\hline
% 			Pose & quaternion & String & Yes \\
% 			\hline
% 			Pose & translation & String & Yes \\			
% 			\hline
% 		\end{tabular}
% 		\caption{Pose Predicates}
% 		\label{table:pose_predicates}
% 	\end{table}
	
% 	\begin{description}
% 		\item[Quaternion] 
% 			%Quaternions are used to describe rotations in a three dimensionally space. \todo{Set reference to a Quaternions description}
% 			In the NEEM version \neemversion we are representing quaternions as a string.
% 			For instance, the quaternion $0.5 + 0.35i + 1j +0k$ will be represented as "0.5 0.35 1 0".
% 		\item[Translation]
% 			The \owlClass{Translation} class represents the 3D vector part of the pose.
% 			In the NEEM version \neemversion we are representing vectors as a string.
% 			For instance, the vector $\begin{bmatrix} -0.759, 1.19, 0.932 \end{bmatrix}^T$ will be represented as "-0.759 1.19 0.932".
			
			



% 	\end{description}
	
	
	
% \subsubsection{Connected Space Region}
% 	\label{sec:connectedSpaceRegion}
% 	Since we are using \cram our robots are allowed to use location designators to describe location parameters which will be resolved to pose \cite{beetz2010cram}
% 	The resolving process is divided in three stages:
% 		\begin{enumerate}
% 			\item Define a abstract location or general location. For instance, "Grab the milk from the fridge.".
% 			\item \cram will try out to resolve "fridge" to an entity of the semantic map.
% 			\item The last step is to resolve the entity from the semantic map into a pose with which the robot can actually work with.
% 		\end{enumerate}
	
% 	\begin{table}[H]
% 		\begin{tabular}{| c | c | c | c |}
% 			\hline			
% 			\textbf{Subject} & \textbf{Predicate} & \textbf{Object} & \textbf{Required}\\
% 			\hline
% 			Connected Space Region & onPhysical & iai-kitchen & No \\
% 			\hline
% 		\end{tabular}
% 		\caption{Connected Space Region Predicates}
% 		\label{table:connected_space_region_predicates}
% 	\end{table}
	
% 	\begin{description}
% 		\item[onPhysical] 
% 			To be able to represent the resolution to an entity of the semantic map we defined the \owlPredicate{onPhysical} predicate.
% 			This predicate points to an instance of semantic map.
% 			For instance, to grasp an object from the kitchen counter in our kitchen we link the \owlClass{ConnectedSpaceRegion} instance to an individual of our semantic mal in this case \textit{knowrob:iai\_kitchen\_sink\_area\_counter\_top}.
% 	\end{description}

% \subsubsection{Timepoint}
% 	In the NEEM version \neemversion the \owlClass{Timepoint} does not have any predicates.
% 	An instance of the \owlClass{Timepoint} class defines a moment in time which is represented in microseconds.
% 	The exact timestamp in microseconds is represent in the name of the instance.
% 	For example, the individual with the name "timepoint\_1523878419.243441" represents a timepoint which is 1523878419243441 microseconds after 00:00:00 UTC, Thursday, 1 January 1970.
% 	We are using the Unix time to represent a time point\cite{matthew2011beginning}.
% 	This Timepoint represenation makes the prolog quering much more easier.

% \input{content/representation/neem-narrative/design-patterns/chapter}


% \input{content/representation/neem-narrative/knowledge-bases/knowledge-bases}
