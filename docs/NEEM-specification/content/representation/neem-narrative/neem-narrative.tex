
% % % % % % % % % % % % % % % % % % % % % % % %
% % % Prelude
% % % % % % % % % % % % % % % % % % % % % % % %
\newcommand{\givenODPNAME}{}
\newcommand{\givenODPINTENT}{}
\newcommand{\givenODPDEFINEDIN}{}
%\newcommand{\givenODPDESCRIPTION}{}
\newcommand{\givenODPGRAPHIC}{}
\newcommand{\givenODPDOMAIN}{}
\newcommand{\givenODPQUESTION}{}
\newcommand{\ODPINTENT}[1]     {\renewcommand{\givenODPINTENT}{#1}}
\newcommand{\ODPDEFINEDIN}[1]  {\renewcommand{\givenODPDEFINEDIN}{#1}}
%\newcommand{\ODPDESCRIPTION}[1]{\renewcommand{\givenODPDESCRIPTION}{#1}}
\newcommand{\ODPGRAPHIC}[1]    {\renewcommand{\givenODPGRAPHIC}{#1}}
\newcommand{\ODPDOMAIN}[1]     {\renewcommand{\givenODPDOMAIN}{#1}}
\newcommand{\ODPQUESTION}[1]   {\renewcommand{\givenODPQUESTION}{#1}}
\newcommand{\OPDinit}{
  \renewcommand{\givenODPINTENT}{REQUIRED!}
  \renewcommand{\givenODPDEFINEDIN}{REQUIRED!}
  %\renewcommand{\givenODPDESCRIPTION}{REQUIRED!}
  \renewcommand{\givenODPGRAPHIC}{REQUIRED!}
  \renewcommand{\givenODPQUESTION}{}
  \renewcommand{\givenODPDOMAIN}{}
  \renewcommand{\labelitemi}{$\mathbf{\sqsubseteq}$}
}

\newenvironment{owlclass}[2][,] {
  \begin{minipage}{5.0cm}
  \begin{center}
  \texttt{\bf#2} \\[-0.2cm]
  \par\noindent\rule{\textwidth}{0.4pt}
  \vspace{-0.6cm}
  \begin{itemize}[#1]
  \raggedright} {
  % % % % % %
  \end{itemize}
  \end{center}
  \end{minipage}
}

\newenvironment{ODP}[1]{
\OPDinit
\renewcommand{\givenODPNAME}{#1}
}{
%\givenODPDESCRIPTION
\begin{figure}[htb!]
\begin{minipage}{0.45\textwidth}
\begin{tabular}{ p{1.8cm} p{3.2cm} }
\toprule
% {\it\bf Name}                 & \emph{\givenODPNAME} \\
{\it\bf Intent}               & \givenODPINTENT \\
{\it\bf Domains}              & \givenODPDOMAIN \\
{\it\bf Competency Questions} & \givenODPQUESTION \\
{\it\bf Defined in}           & \givenODPDEFINEDIN \\
\bottomrule
\end{tabular}
\end{minipage}
\begin{minipage}{0.55\textwidth}
\begin{center}
\givenODPGRAPHIC
\end{center}
\end{minipage}
\caption{\emph{\givenODPNAME}.}
\end{figure}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{NEEM-Narrative}
\label{ch:narrative}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Taxonomy}
\label{sec:taxonomy}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Occurrences}
\label{sec:occurrences}
The basic building blocks of a NEEM are the events that occur during the course of an activity. An event is defined as \emph{any physical, social, or mental process, event, or state}. Events have an associated time interval that determines the time at which the event occurs. Time data is represented as unix timestamps, or using XSD date types. As discussed in porevious section, we distinguish between three different event classes: \owlClass{Action}, \owlClass{State}, and \owlClass{Process}.

\begin{ODP}{The Representation of Occurences}
\ODPINTENT{To represent that something has happened.}
\ODPDOMAIN{\texttt{Event observation}}
\ODPDEFINEDIN{DUL.owl}
\ODPQUESTION{
    \emph{Did it happen?}
    \emph{When did it happen?}}
\ODPGRAPHIC{
\begin{tikzpicture}
    \node[owlclass] (EVT) {\begin{owlclass}{Event}
        \item \texttt{Entity}
    \end{owlclass}};
    \node[owlclass,below=0.6cm of EVT] (TI) {\begin{owlclass}{Time Interval}
        \item \texttt{Region}
    \end{owlclass}};
    \node[data,below=0.6cm of TI,xshift=-1.2cm] (BEGIN) {xsd:double};
    \node[data,below=0.6cm of TI,xshift=1.2cm] (END) {xsd:double};
    \draw (EVT) edge[relation] node[midway,label=right:hasTimeInterval] {} (TI);
    \draw (TI) edge[relation] node[midway,label=left:hasIntervalBegin] {} (BEGIN);
    \draw (TI) edge[relation] node[midway,label=right:hasIntervalEnd] {} (END);
\end{tikzpicture}
}
\end{ODP}

To deal with occurences, the EASE knowledge base provides the unary \emph{occurs} predicate whose argument is an event entity. The statement that an event named \emph{MyEvent} occurs can be written as: \emph{occurs('MyEvent')}. Temporal scoping is used to assign time data to occurences. The statement that an event occurred between some timestamps can be written using the \emph{during} keyword: \emph{occurs('MyEvent') during [10.0,14.0]}, where $10.0$ denotes the begin of the event, and $14.0$ the end.
It is further valid to assert partial time data using the keywords \emph{since} and \emph{until}.

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Participation}
\label{sec:participation}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Composition}
\label{sec:composition}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Qualification}
\label{sec:qualification}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Classification}
\label{sec:classification}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Interpretation}
\label{sec:interpretation}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Transformation}
\label{sec:transformation}

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\iffalse
\subsection{Events}
\begin{itemize}
\item show SOMA Figure highlight event branch
\item write about different types of events
\item write about relationships between events
\item write about relationships between events and objects
\item provide examples of everything
\item display examples as graph figures
\end{itemize}

\subsubsection{Occurs}
\textbf{events occur, they have a time interval}

\subsubsection{Participation}
\textbf{objects participate in events}

\subsubsection{Classification}

\paragraph{Process vs. Action ODP}
\begin{ODP}{Process vs. Action}
%\ODPDESCRIPTION{An Action is an Event with at least one Agent participant, such that this Agent has a Task, often defined by a Plan or Workflow, which it executes through the Action. A Process is an Event for which no such commitments have been made. In DUL, these classes are not disjoint, allowing a particular event individual to be classified as either, depending on whether we care to record an agent and its goals or not. In EASE, we use Process as a top-level class for events with no agentive participant.}
\ODPINTENT{To represent the intentional and agentive structure-- or lack thereof-- behind Events.}
\ODPDOMAIN{
  \texttt{Event classification},
  \texttt{Event narratives}}
\ODPDEFINEDIN{DUL.owl}
\ODPQUESTION{
  \emph{Is there anyone responsible for the event?}
  \emph{What are they trying to do?}
  \emph{How did an event unfold?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (ACTION) {
 \begin{owlclass}{Action}
  \item \texttt{Event}
  \item $(\exists \emph{hasParticipant}.\texttt{Agent})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of ACTION] (PROCESS) {
 \begin{owlclass}{Process}
  \item \texttt{Event}
 \end{owlclass}
 };
\end{tikzpicture}
}
\end{ODP}

\textbf{tasks are used to classify events}
\paragraph{Task Execution ODP}
\begin{ODP}{Task Execution}
%\ODPDESCRIPTION{This ODP allows to make assertions on roles played by agents without involving the agents that play that roles, and vice versa. It allows to express neither the context type in which tasks are defined, not the particular context in which the action is carried out. Moreover, it does not allow to express the time at which the task is executed through the action (for actions that do not solely execute that certain task).}
\ODPINTENT{To represent actions through which tasks are executed. }
\ODPDOMAIN{
  \texttt{Organization},
  \texttt{Management},
  \texttt{Scheduling},
  \texttt{Workflow}}
\ODPDEFINEDIN{DUL.owl}
\ODPQUESTION{
  \emph{Which task is executed through this action?}
  \emph{What actions can execute that task?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (ACTION) {
 \begin{owlclass}{Action}
  \item $(\geq 1\ \emph{executesTask}.\texttt{Task})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of ACTION] (TASK) {
 \begin{owlclass}{Task}
  \item $(\forall \emph{isExecutedIn}.\texttt{Action})$
 \end{owlclass}
 };
 \draw (ACTION) edge[thick,-,dashed,blue!60] (TASK);
\end{tikzpicture}
}
\end{ODP}

\subsubsection{Composition / Constituency}
\textbf{events may have sub-events, or some other events that are constituents of it. the structure of events is described in plans. Plans use Allen's relations to structure the event, etc.}

\paragraph{State, Configuration, Gestallt ODP}
\begin{ODP}{State, Configuration, Gestallt}
%\ODPDESCRIPTION{A state is a configuration of the world that is construed to be stable on its own. Outside disturbances may cause state transitions, and the settling into some other, self-stable configuration. A State is also characterized by a Description, that indicates things such as what kind of entities participate in the state, what relations might exist between them, what regions may be used by particular qualities of the participants. This Description is, in general, referred to as a Configuration, however some common examples are Goals-- describe desired states of the world--, Norms-- describe states that should be kept--, and Diagnoses-- describe a state that causes certain observable symptoms. States are classified by Gestallts. \textbf{TODO}: Generalize this and/or split it: classification by an event type and structuring by a description are different ODPs in the current list. All three event subclasses (Actions, Processes, States) now are each part of their own Event-Concept-Description triad, where the Concept classifies the Event, and the Description, by describing the classifying Concept, structures the Event.
}
\ODPINTENT{Ontological representation for situations in the world that are cognitively construed as stable arrangements of entities.}
\ODPDOMAIN{
  \texttt{Event classification},
  \texttt{Event narratives}}
\ODPDEFINEDIN{EASE-STATE.owl}
\ODPQUESTION{
  \emph{What are stable arrangements?}
  \emph{What is meant by ``state'' of the world?}
  \emph{What characterizes a state?}}
\emph{Examples}
%\begin{itemize}
%  \item AssemblyConnection: two objects are in a rigid connection, such that the movement of one determines the movement of the other. In this case the characterizing Configuration for this State uses several Roles-- one for each part/geometric feature belonging to the connected objects-- and puts constraints on the relative positioning of these geometric features such that they interlock to produce the rigid connection.
%  \item Contact: two objects are in mechanical contact. The characterizing Configuration uses two Roles, one for each participating object, and puts constraints on the Pose qualities of the participants: the poses should be such that the participants touch.
%  \item FunctionalControl: an object restricts the movement of another, at least partially. The Configuration uses the Roles Item and Restrictor. More concrete examples are Containment: the Restrictor is a Container, and the Pose quality of the Item should use the region inside the Container; and Support: both Restrictor and Item are objects, placed in such a way that the Item does not move because of gravity.
%  \item PhysicallyAccessible: the Configuration for this state uses the roles Item, a Container or Protector, and optionally an Accessor and a Task, and states that an Item is either placed in a Container or protected by a Protector, but the placement of the Item and Container is such that an Accessor may nevertheless reach the Item in order to perform a Task. For a more concrete example, a DoorOpen is a kind of PhysicallyAccessible where the Protector is a door, the Item is the inside of the room behind the door, the Accessor is some person and the Task is to walk into the inside of the room.
%\end{itemize}
\end{ODP}

\subsubsection{Interpretation}
\textbf{events are interpreted through situations that satisfy some description of the task that is executed.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %
\subsection{Object Branch in SOMA}

\subsubsection{Classification}

%\newpage
\paragraph{Designed Artifact ODP}
\begin{ODP}{Designed Artifact}
%\ODPDESCRIPTION{A DesignedArtifact is a physical object described by a Design. In EASE, Designs refer to the form, but also the function of an object. This allows us to say that an object is ``for'' a particular purpose, even though it might be used for something else instead. For example, a cup is a BeverageContainer but can be used as a Flowerpot. Designs form a hierarchy of specificity, for example $DesignMilkContainer \sqsubseteq DesignBeverageContainer \sqsubseteq DesginContainer \sqsubseteq Design$. The justification for this pattern is that the type of an object is rigid, but the roles it plays in events change. A naive taxonomy, without a notion similar to Design, cannot tackle the fact that objects are usable in several ways beyond the obvious; a hammer isn't always a hammer, sometimes it's a paperweight. On the other hand, a usable ontology of objects must take into account how human users refer to objects by their default use.}
\ODPINTENT{To explicate the intuitive classification human users would have of objects, based on their default uses.}
\ODPDOMAIN{
  \texttt{Object classification},
  \texttt{Event narratives}}
\ODPDEFINEDIN{DUL.owl, EASE.owl, EASE-middle.owl}
\ODPQUESTION{
  \emph{What sort of object is this?}
  \emph{What is the intended use of the object?}
  \emph{How did an event unfold?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (DESIGNEDARTIFACT) {
 \begin{owlclass}{DesignedArtifact}
  \item \texttt{PhysicalArtifact}
  \item $(\exists\emph{isDescribedBy}.\texttt{Design})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of DESIGNEDARTIFACT] (DESIGN) {
 \begin{owlclass}{Design}
  \item \texttt{Description}
 \end{owlclass}
 };
 \draw (DESIGNEDARTIFACT) edge[thick,-,dashed,blue!60] (DESIGN);
\end{tikzpicture}
}
\end{ODP}

\subsubsection{Qualification}

\paragraph{Quality -- Region ODP}
\begin{ODP}{Quality -- Region}
%\ODPDESCRIPTION{This ODP allows structuring information about the properties of an Entity. It distinguishes between dependent aspects of the Entity (things that cannot exist without the Entity itself existing), and the values that may be ascribed to those aspects. These values may be points in some Region. Note that a Region may be a finite set of discrete labels, allowing for ``qualitative'' descriptions, but more often a Region is some dimensional space allowing ``quantitative'' descriptions. A Region may contain a single point, in cases where the value of a Quality is known precisely.}
\ODPINTENT{To distinguish between an aspect of an Entity and a particular numerical description of it.}
\ODPDOMAIN{
  \texttt{Measurement},
  \texttt{Object representation},
  \texttt{Environment representation},
  \texttt{Execution status}}
\ODPDEFINEDIN{DUL.owl}
\ODPQUESTION{
  \emph{What qualities does an entity have?}
  \emph{What are possible values for a quality?}
  \emph{What is the actual value of a quality for a particular entity (at a particular time)?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (QUALITY) {
 \begin{owlclass}{Quality}
  \item $(\exists \emph{isQualityOf}.\texttt{Entity})$
  \item $(\exists \emph{hasRegion}.\texttt{Region})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of QUALITY] (REGION) {
 \begin{owlclass}{Region}
  \item $(\exists \emph{isRegionFor}.\texttt{Quality})$
 \end{owlclass}
 };
 \draw (QUALITY) edge[thick,-,dashed,blue!60] (REGION);
\end{tikzpicture}
}
\end{ODP}

\subsubsection{Transformation}
\paragraph{Transient ODP}
\begin{ODP}{Transient}
%\ODPDESCRIPTION{This pattern addresses the fact that objects change by undergoing/taking part in Processes. For example, the PancakeMix becomes, through Baking, a Pancake. However, the ontological status of the object while the process takes place is unclear: the object placed on the frying pan is not a Pancake until Baking finishes, but it's not PancakeMix either once it begins to coagulate. In the EASE approach, the object in-between such characterizations is a Transient. A Transient transitionsFrom an Object, and possibly transitionsTo an Object. It may also be the case that a Transient transitionsBack to an Object, to indicate that once the process completes, the same Object is restored; this would be the case for example for catalysts in chemistry, or a loaf of bread after slicing, if there is enough bread left.}
\ODPINTENT{Ontological classification for objects undergoing type changes.}
\ODPDOMAIN{
  \texttt{Object classification},
  \texttt{Event narratives}}
\ODPDEFINEDIN{EASE.owl, EASE-middle.owl}
\ODPQUESTION{
  \emph{What sort of object is this?}
  \emph{What objects ``went'' in the making of another?}
  \emph{Does an object preserve or restore its identity after change?}}
\ODPGRAPHIC{
\begin{tikzpicture}
 \node[owlclass] (TRANSIENT) {
 \begin{owlclass}{Transient}
  \item \texttt{Object}
  \item $(\exists\emph{transitionsFrom}.\texttt{Object})$
  \item $(\forall\emph{transitionsTo}.\texttt{Object})$
 \end{owlclass}
 };
 \node[owlclass,below=0.6cm of TRANSIENT] (TRANSITIONSBACK) {
 \begin{owlclass}{transitionsBack}
  \item \texttt{transitionsFrom}
  \item \texttt{transitionsTo}
 \end{owlclass}
 };
\end{tikzpicture}
}
\end{ODP}
\fi

% % % % % % % % % % % % % % % % %
% % % % % % % % % % % % % % % % %

%\subsection{Actions}

%\todo{Describe ACT, PROC, STATE from the SOMA paper}

%\subsubsection{Ontology Design Patterns (ODP)}

%\newpage
%\subsubsection{Process vs. Action ODP}

%\begin{ODP}{Process vs. Action}
%\ODPDESCRIPTION{An Action is an Event with at least one Agent participant, such that this Agent has a Task, often defined by a Plan or Workflow, which it executes through the Action. A Process is an Event for which no such commitments have been made. In DUL, these classes are not disjoint, allowing a particular event individual to be classified as either, depending on whether we care to record an agent and its goals or not. In EASE, we use Process as a top-level class for events with no agentive participant.}
%\ODPINTENT{To represent the intentional and agentive structure-- or lack thereof-- behind Events.}
%\ODPDOMAIN{
%  \texttt{Event classification},
%  \texttt{Event narratives}}
%\ODPDEFINEDIN{DUL.owl}
%\ODPQUESTION{
%  \emph{Is there anyone responsible for the event?}
%  \emph{What are they trying to do?}
%  \emph{How did an event unfold?}}
%\ODPGRAPHIC{
%\begin{tikzpicture}
% \node[owlclass] (ACTION) {
% \begin{owlclass}{ACTION}
%  \item \texttt{Event}
%  \item $(\exists \emph{hasParticipant}.\texttt{Agent})$
% \end{owlclass}
% };
% \node[owlclass,below=0.6cm of ACTION] (PROCESS) {
% \begin{owlclass}{Process}
%  \item \texttt{Event}
% \end{owlclass}
% };
%\end{tikzpicture}
%}
%\end{ODP}

%\newpage


%\todo{Describe the OBJ Module of Soma}

%\subsection{Situations}

%\todo{Describe the EXEC Module of Soma}

%\subsubsection{Ontology Design Patterns (ODP)}


% In version \neemversion the \neemnar consists the belief state and action task hierarchy. 
% In the following sections we will describe how the belief state and action task hierarchy are represented.
% An concrete example for a logged \neemnar will be given in Chapter \ref{ch:example}.

% \subsection{Belief State}
% \input{content/representation/neem-narrative/beliefstate}

% \subsection{Action Hierarchy}
% \label{ch:narrative,sec:actionHierarchy}
% In this section, we will describe how an action task hierarchy is represented in the \neemnar. 
% Since we are using \cram on our robots our plans do not necessary generate a sequence of actions, instead they will generate rather an hierarchy of actions.
% During the plan execution we are logging all executed actions with its parameters and represent the hierarchy in \owl.
% The general idea of the model is that an action will be represented as an individual of the class \owlClass{knowrob:'Action'}.
% This individual can be a direct instance of the class \owlClass{knowrob:'Action'} or its subclass.
% \todo{Add all supported action sub classes}
% With the predicates \owlPredicate{subAction}, \owlPredicate{previousAction} and \owlPredicate{nextAction}, which all have as subject and object the type \owlClass{knowrob:'Action'}, we are able to represent the action hierarchy.
% In our understanding an logged action hierarchy in an \owl represents all actions which were executed during an experiment.
% Meaning, if we would extracted all actions from the \owl file and recreated the action tree, we would be able to analyze and reasoning about all executed actions during one specific experiment.

% In the next subsections we will describe the predicates and classes which we currently defined in the version \neemversion to log the actions which were executed by the robot during an experiment. 

% \subsection{Action Predicates}
% Every individual of the class \owlClass{knowrob:'Action'} class or its subclass which will be logged in the \owl file can be asserted with the following predicates (see Table \ref{table:action_task_predicates}).
% Some predicates in the table are marked as required.
% This means that if you are intending to upload your \owl file to \openease, every \owlClass{knowrob:'Action'} individual has to have the required properties asserted.
% %Otherwise the \owl file will be revoked from the server.\todo{We have to implement such checking in \openease.}
% The \openease server checks also if the objects of the predicates are associated with the correct class.

% \begin{table}[H]
% 	\begin{tabular}{| c | c | c | c |}
% 		\hline			
% 		\textbf{Subject} & \textbf{Predicate} & \textbf{Object}  & \textbf{Required} \\
% 		\hline
% 		Action & taskSuccess & xsd:boolean & Yes \\
% 		\hline
% 		Action & startTime & Timepoint & Yes \\
% 		\hline
% 		Action & endTime & Timepoint  & Yes \\
% 		\hline
% 		Action & subAction & Action & No \\
% 		\hline
% 		Action & nextAction & Action & No \\
% 		\hline
% 		Action & previousAction & Action & No \\
% 		\hline
% 	\end{tabular}
% 	\caption{Action Predicates}
% 	\label{table:action_task_predicates}
% \end{table}

% \begin{description}
% 	\item[\textbf{taskSuccess}] 
% 		This predicates points to data type \owlClass{xsd:boolean}.
% 		The value \textbf{true} represents that the action was executed successfully.
% 		If any errors occurred during the action execution, the data type will be set to \textbf{false}.
% 		\footnote{In the NEEM version \neemversion we do not log the exact error which happened during action.}
% 	\item[\textbf{startTime}]
% 		The \owlPredicate{startTime} represents when the action started.
% 		Instead of representing the startTime as a data point, we are creating an instance of the class \owlClass{Timepoint}.
% 		The implemenation is done in that way because it made writing prolog queries much more convenient. 
% 		The name of the individual is representing the exact time when the action started e.g.\ \textit{timepoint\_1523878415038090} which can be understood that the action started 1523878415038090 microseconds after 00:00:00 UTC, Thursday, 1 January 1970.
% 		We are using the Unix time to represent a time point \cite{matthew2011beginning}.
% 		However, we are considering to measure the time in microseconds.
% 		The reason for this decision is that we also want to create NEEMs in simulation.
% 		However, tasks in simulation can be executed so fast that logging in microseconds allowed to measure the performance of the task executions.
% 		Also the measurement in microseconds allowed to differentiate the running time between tasks.
% 	\item[\textbf{endTime}] 
% 		This predicate represents when the action ended.
% 		More information about how we log time points is described in the predicate description \owlPredicate{startTime}.
% 	\item[\textbf{subAction}]
% 		The predicate \owlPredicate{subAction} allows to create parent-child relation between two tasks. In the context of this predicate, the subject is the parent action and the object is the child action.
% 		It is possible that an \owlClass{Action} instance can have multiple \owlPredicate{subAction} predicates which point each to a single child action.
% 	\item[\textbf{nextAction}]
% 		To be able to create an sequential order of actions which where executed on the same hierarchy level, we defined the \owlPredicate{nextAction} predicate.
% 		The subject represents the action which was started first and points to the next sibling actions.
% 		\footnote{In the NEEM version \neemversion we are not differentiate if actions were executed in sequence or in parallel.}
% 	\item[\textbf{previousAction}]
% 		Like in \owlPredicate{previousAction} this predicate is created to create an sequential order between siblings tasks.
% 		However in this case, \owlPredicate{previousAction} connects an \owlClass{Action} instance with the sibling action which was performed previously.
% \end{description}


% \subsection{Action Parameter Predicates}
% 	\label{sec:actionParameterPredicactes}
% 	In general, actions have to have parameters which have to be asserted.
% 	Based on those assertions \cram is able to infer how to perform the task.
% 	For instance, a grasping task will be executed differently when the target object is a spoon compared to when the target object is a bottle.
% 	To understand the logged behavior of the robot better, we are logging to each action the corresponding parameters.
% 	For \cram we are using for our actions a set of predefined parameters.
% 	For example, when an action requires an object every \cram action has parameter name \textit{object} asserted.
% 	During the logging process, we are creating based on the parameter's value an instance of the class \owlClass{Object} and connect this instance with the \owlPredicate{objectActedOn}.
% 	\todo{Ref to belief state when object description is done}
% 	This implementation allows us to use the logger for new actions without the need to extend the logger.
% 	As long the \cram actions will use the predefined parameter names all parameters will be logged without the need to extend the logger.
% 	All predefined parameters are represented by a separated predicates which point to the parameter value which is an individual of the corresponding \owl class.
% 	Table \ref{table:action_parameter_predicates} shows the current parameter predicates which are supported by our NEEM representation.
% 	The design of the action parameter predicates is based on the work with our \pr.
% 	Therefore in the NEEM \neemversion it might be possible that the action parameters cannot be used by everyone in this state.
	 
% \begin{table}[H]
% \begin{tabular}{| c | c | c |}
% 	\hline			
% 	\textbf{Subject} & \textbf{Predicate} & \textbf{Object} \\
% 	\hline			
% 	Action & effort & qudt\#NewtonMeter \\
% 	\hline
%     Action & position & Float \\
%     \hline
% 	Action & arm & Pr2\#Pr2RightArm \\
% 	\hline
% 	Action & bodyPartsUsed & Pr2\#Pr2RightGripper \\
% 	\hline
% 	Action & goalLocation & Pose or Connected Space Region \\
% 	\hline
%     Action & objectActedOn & Object \\
% 	\hline
% 	Action & objectType & Object \\
% 	\hline
% \end{tabular}
% 	\caption{Action Parameter Predicates}
% 	\label{table:action_parameter_predicates}
% \end{table}

% \begin{description}
% 	\item[\textbf{effort}] 
% 		Effort is the grasping force in newton-meters.
% 		To model this we are using the \qudt ontology \footnote{http://qudt.org/}.
% 	\item[\textbf{position}]
% 		We are using this predicate to log the the goal position for the gripper of the \pr.
% 		The \pr accepts a joint angle in RAD to position its gripper.
% 		We decided to use a float data type to model the position to be able to represent more different types of position.
% 		For instance, our \boxy robot uses centimeters to position the gripper.
% 		Therefore with a float representation we are able to log from both robots the position parameter.
% 	\item[\textbf{arm}]
% 		With this predicate we want to log which arm was used to by the robot.
% 		The predicate points to an instance of the specific robot arm class.
% 		For instance, to model that the \pr used a right arm to grasp a bottle we are asserting the \owlPredicate{arm} predicate to an individual of the class \owlClass{Pr2RightArm}\footnote{http://knowrob.org/kb/PR2.owl}.
% 	\item[\textbf{bodyPartsUsed}]
% 		The \owlPredicate{bodyPartsUsed} predicate should represent which body part from the robot was used to perform the task.
% 		This predicate can be used \eg to represent that a gripper was used to perform the task.
% 		Like in \dots we also want to represent the body part as instance of the class which represents the body part.
% 	\item[\textbf{goalLocation}]
% 		This predicate can be used to represent the target or location parameter of an action.
% 		This predicate is suitable to represent \eg the target location of an \textit{Going} action.
% 		We are considering to different object types to log the goal location.
% 		Since our robots are build on \ros our robots can work with \textit{Poses} \footnote{http://docs.ros.org/api/geometry\_msgs/html/msg/Pose.html}.
% 		How we represent this \owl class is stated out in section \ref{sec:pose}.
		
% 		Since we are also using \cram, our robots can also encounter \textit{location designator} as goal locations\cite{beetz2010cram}.
% 		That means \cram can handle tasks like "Go to the kitchen counter".
% 		Since locations designators are more abstract we use the \owl class \owlClass{Connected Space Region} to log them.
% 		A more detailed description is given in section \ref{sec:connectedSpaceRegion}.
		
% 	\item[\textbf{objectActedOn}]
% 		With the predicate \owlClass{objectActedOn} we want to log which objects are given as parameter to the action.
% 		For instance, we can log which objects the robots looked for during a perception task and what objects he tried to grab.
% 	\item[\textbf{objectType}]
% 		The difference of \owlPredicate{objectType} compared to \owlPredicate{objectActedOn} is that \owlPredicate{objectType} define not a specific object but rather an object in general.
% 		For instance, if the robotic agent will get a task such as "grab the milk from the fridge".
% 		Given the task, the agent knows only that it has to grab a object of the type of milk from the fridge.
% 		So at this moment the robot does not know if the a milk box is actually in the fridge.
% 		Thereofre it has to recognize the milk first.
% 		If this was sucessfull then the robot will assoicated the following task the milk ID with the predicate \owlPredicate{objectActedOn} which the object will be the link to the speicifc object in the belieft state.
% \end{description}

% \subsection{Action Parameter Classes}
% As shown in section \ref{sec:actionParameterPredicactes} we are not only using data types to log the action parameter.
% In this section we are describing the \owl classes which we introduced to be able to log all parameters which we required to log during our experiments.

% \subsubsection{Pose}
% 	\label{sec:pose}
% 	This class is used to log coordinates given as parameter.
% 	Since our robots are using \ros we are logging poses.
% 	A pose consists from a Quaternion and a 3D vector.
% 	Since both together can only describe a Pose, both entities are required to be logged.
% 	\begin{table}[H]
% 		\begin{tabular}{| c | c | c | c |}
% 			\hline			
% 			\textbf{Subject} & \textbf{Predicate} & \textbf{Object} & \textbf{Required}\\
% 			\hline
% 			Pose & quaternion & String & Yes \\
% 			\hline
% 			Pose & translation & String & Yes \\			
% 			\hline
% 		\end{tabular}
% 		\caption{Pose Predicates}
% 		\label{table:pose_predicates}
% 	\end{table}
	
% 	\begin{description}
% 		\item[Quaternion] 
% 			%Quaternions are used to describe rotations in a three dimensionally space. \todo{Set reference to a Quaternions description}
% 			In the NEEM version \neemversion we are representing quaternions as a string.
% 			For instance, the quaternion $0.5 + 0.35i + 1j +0k$ will be represented as "0.5 0.35 1 0".
% 		\item[Translation]
% 			The \owlClass{Translation} class represents the 3D vector part of the pose.
% 			In the NEEM version \neemversion we are representing vectors as a string.
% 			For instance, the vector $\begin{bmatrix} -0.759, 1.19, 0.932 \end{bmatrix}^T$ will be represented as "-0.759 1.19 0.932".
			
			



% 	\end{description}
	
	
	
% \subsubsection{Connected Space Region}
% 	\label{sec:connectedSpaceRegion}
% 	Since we are using \cram our robots are allowed to use location designators to describe location parameters which will be resolved to pose \cite{beetz2010cram}
% 	The resolving process is divided in three stages:
% 		\begin{enumerate}
% 			\item Define a abstract location or general location. For instance, "Grab the milk from the fridge.".
% 			\item \cram will try out to resolve "fridge" to an entity of the semantic map.
% 			\item The last step is to resolve the entity from the semantic map into a pose with which the robot can actually work with.
% 		\end{enumerate}
	
% 	\begin{table}[H]
% 		\begin{tabular}{| c | c | c | c |}
% 			\hline			
% 			\textbf{Subject} & \textbf{Predicate} & \textbf{Object} & \textbf{Required}\\
% 			\hline
% 			Connected Space Region & onPhysical & iai-kitchen & No \\
% 			\hline
% 		\end{tabular}
% 		\caption{Connected Space Region Predicates}
% 		\label{table:connected_space_region_predicates}
% 	\end{table}
	
% 	\begin{description}
% 		\item[onPhysical] 
% 			To be able to represent the resolution to an entity of the semantic map we defined the \owlPredicate{onPhysical} predicate.
% 			This predicate points to an instance of semantic map.
% 			For instance, to grasp an object from the kitchen counter in our kitchen we link the \owlClass{ConnectedSpaceRegion} instance to an individual of our semantic mal in this case \textit{knowrob:iai\_kitchen\_sink\_area\_counter\_top}.
% 	\end{description}

% \subsubsection{Timepoint}
% 	In the NEEM version \neemversion the \owlClass{Timepoint} does not have any predicates.
% 	An instance of the \owlClass{Timepoint} class defines a moment in time which is represented in microseconds.
% 	The exact timestamp in microseconds is represent in the name of the instance.
% 	For example, the individual with the name "timepoint\_1523878419.243441" represents a timepoint which is 1523878419243441 microseconds after 00:00:00 UTC, Thursday, 1 January 1970.
% 	We are using the Unix time to represent a time point\cite{matthew2011beginning}.
% 	This Timepoint represenation makes the prolog quering much more easier.

% \input{content/representation/neem-narrative/design-patterns/chapter}
% \input{content/representation/neem-narrative/knowledge-bases/knowledge-bases}
